{"remainingRequest":"e:\\QuanLyDaoTao\\Front-end\\node_modules\\babel-loader\\lib\\index.js!e:\\QuanLyDaoTao\\Front-end\\src\\app\\state\\middlewares\\apiService.js","dependencies":[{"path":"e:\\QuanLyDaoTao\\Front-end\\src\\app\\state\\middlewares\\apiService.js","mtime":1557328761238},{"path":"e:\\QuanLyDaoTao\\Front-end\\.babelrc","mtime":1554785266000},{"path":"e:\\QuanLyDaoTao\\Front-end\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"e:\\QuanLyDaoTao\\Front-end\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { fetch } from \"../utils\"; // const baseUrl = typeof document === \"undefined\" ? \"http://5ca705a29853bd0014973545.mockapi.io/api\" : \"/api\";\n\nvar baseUrl = \"http://localhost:8080/api\";\n\nfunction handleErrors(err, action, next) {\n  next({\n    type: \"\".concat(action.type, \"_FAILED\"),\n    payload: err,\n    meta: action.meta\n  });\n  return Promise.reject(err);\n}\n\nfunction handleResponse(res, action, next) {\n  next({\n    type: \"\".concat(action.type, \"_COMPLETED\"),\n    payload: res,\n    meta: action.meta\n  });\n  return res;\n}\n\nvar apiService = function apiService() {\n  return function (next) {\n    return function (action) {\n      var result = next(action);\n\n      if (!action.meta || !action.meta.async) {\n        return result;\n      }\n\n      var _action$meta = action.meta,\n          path = _action$meta.path,\n          _action$meta$method = _action$meta.method,\n          method = _action$meta$method === void 0 ? \"GET\" : _action$meta$method,\n          body = _action$meta.body,\n          header = _action$meta.header;\n\n      if (!path) {\n        throw new Error(\"'path' not specified for async action \".concat(action.type));\n      }\n\n      var url = \"\".concat(baseUrl).concat(path);\n      return fetch(url, method, body, header).then(function (res) {\n        return handleResponse(res, action, next);\n      }, function (err) {\n        return handleErrors(err, action, next);\n      });\n    };\n  };\n};\n\nexport default apiService;",{"version":3,"sources":["e:\\QuanLyDaoTao\\Front-end\\src\\app\\state\\middlewares\\apiService.js"],"names":["fetch","baseUrl","handleErrors","err","action","next","type","payload","meta","Promise","reject","handleResponse","res","apiService","result","async","path","method","body","header","Error","url","then"],"mappings":"AAAA,SAASA,KAAT,QAAsB,UAAtB,C,CAEA;;AACA,IAAMC,OAAO,GAAG,2BAAhB;;AAEA,SAASC,YAAT,CAAuBC,GAAvB,EAA4BC,MAA5B,EAAoCC,IAApC,EAA2C;AACvCA,EAAAA,IAAI,CAAE;AACFC,IAAAA,IAAI,YAAMF,MAAM,CAACE,IAAb,YADF;AAEFC,IAAAA,OAAO,EAAEJ,GAFP;AAGFK,IAAAA,IAAI,EAAEJ,MAAM,CAACI;AAHX,GAAF,CAAJ;AAKA,SAAOC,OAAO,CAACC,MAAR,CAAgBP,GAAhB,CAAP;AACH;;AAED,SAASQ,cAAT,CAAyBC,GAAzB,EAA8BR,MAA9B,EAAsCC,IAAtC,EAA6C;AACzCA,EAAAA,IAAI,CAAE;AACFC,IAAAA,IAAI,YAAMF,MAAM,CAACE,IAAb,eADF;AAEFC,IAAAA,OAAO,EAAEK,GAFP;AAGFJ,IAAAA,IAAI,EAAEJ,MAAM,CAACI;AAHX,GAAF,CAAJ;AAKA,SAAOI,GAAP;AACH;;AAED,IAAMC,UAAU,GAAG,SAAbA,UAAa;AAAA,SAAO,UAAER,IAAF;AAAA,WAAY,UAAED,MAAF,EAAc;AAChD,UAAMU,MAAM,GAAGT,IAAI,CAAED,MAAF,CAAnB;;AACA,UAAK,CAACA,MAAM,CAACI,IAAR,IAAgB,CAACJ,MAAM,CAACI,IAAP,CAAYO,KAAlC,EAA0C;AACtC,eAAOD,MAAP;AACH;;AAJ+C,yBAKDV,MAAM,CAACI,IALN;AAAA,UAKxCQ,IALwC,gBAKxCA,IALwC;AAAA,6CAKlCC,MALkC;AAAA,UAKlCA,MALkC,oCAKzB,KALyB;AAAA,UAKlBC,IALkB,gBAKlBA,IALkB;AAAA,UAKZC,MALY,gBAKZA,MALY;;AAOhD,UAAK,CAACH,IAAN,EAAa;AACT,cAAM,IAAII,KAAJ,iDAAqDhB,MAAM,CAACE,IAA5D,EAAN;AACH;;AAED,UAAMe,GAAG,aAAOpB,OAAP,SAAmBe,IAAnB,CAAT;AACA,aAAOhB,KAAK,CAAEqB,GAAF,EAAOJ,MAAP,EAAeC,IAAf,EAAqBC,MAArB,CAAL,CAAmCG,IAAnC,CACH,UAAAV,GAAG;AAAA,eAAID,cAAc,CAAEC,GAAF,EAAOR,MAAP,EAAeC,IAAf,CAAlB;AAAA,OADA,EAEH,UAAAF,GAAG;AAAA,eAAID,YAAY,CAAEC,GAAF,EAAOC,MAAP,EAAeC,IAAf,CAAhB;AAAA,OAFA,CAAP;AAIH,KAhByB;AAAA,GAAP;AAAA,CAAnB;;AAkBA,eAAeQ,UAAf","sourcesContent":["import { fetch } from \"../utils\";\n\n// const baseUrl = typeof document === \"undefined\" ? \"http://5ca705a29853bd0014973545.mockapi.io/api\" : \"/api\";\nconst baseUrl = \"http://localhost:8080/api\";\n\nfunction handleErrors( err, action, next ) {\n    next( {\n        type: `${ action.type }_FAILED`,\n        payload: err,\n        meta: action.meta,\n    } );\n    return Promise.reject( err );\n}\n\nfunction handleResponse( res, action, next ) {\n    next( {\n        type: `${ action.type }_COMPLETED`,\n        payload: res,\n        meta: action.meta,\n    } );\n    return res;\n}\n\nconst apiService = ( ) => ( next ) => ( action ) => {\n    const result = next( action );\n    if ( !action.meta || !action.meta.async ) {\n        return result;\n    }\n    const { path, method = \"GET\", body, header } = action.meta;\n\n    if ( !path ) {\n        throw new Error( `'path' not specified for async action ${ action.type }` );\n    }\n\n    const url = `${ baseUrl }${ path }`;\n    return fetch( url, method, body, header ).then(\n        res => handleResponse( res, action, next ),\n        err => handleErrors( err, action, next ),\n    );\n};\n\nexport default apiService;"]}]}